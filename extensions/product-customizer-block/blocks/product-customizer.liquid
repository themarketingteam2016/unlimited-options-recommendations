{% comment %}
  Product Customizer Integration

  Usage: Include this snippet in your product template
  {% render 'product-customizer', product: product %}
{% endcomment %}

<div id="unlimited-customizer-{{ product.id }}" class="unlimited-customizer" data-product-id="{{ product.id }}">
  <div class="unlimited-customizer__loading">
    <div class="spinner"></div>
    Loading customizer...
  </div>
</div>

<script>
(function() {
  const productId = 'gid://shopify/Product/{{ product.id }}';
  const container = document.getElementById('unlimited-customizer-{{ product.id }}');

  // Configuration - Update this with your app URL
  const APP_URL = 'https://unlimtited-options-recommendations.vercel.app';

  let variants = [];
  let attributes = [];
  let selectedOptions = {};
  let selectedVariant = null;
  let recommendations = [];
  let selectedRecommendations = new Set();
  let recommendationVariantsCache = {};
  let productDataCache = {};

  // Fetch product customizer data
  async function loadCustomizer() {
    try {
      // Fetch variants from your API
      const variantsRes = await fetch(`${APP_URL}/api/products/${encodeURIComponent(productId)}/variants`);
      const variantsData = await variantsRes.json();

      if (!variantsData || variantsData.length === 0) {
        container.innerHTML = '<p>No custom options available for this product.</p>';
        return;
      }

      variants = variantsData;

      // Extract unique attributes
      const uniqueAttrs = {};
      variants.forEach(variant => {
        variant.variant_options?.forEach(opt => {
          if (opt.attribute) {
            if (!uniqueAttrs[opt.attribute.id]) {
              uniqueAttrs[opt.attribute.id] = {
                ...opt.attribute,
                values: []
              };
            }
            if (!uniqueAttrs[opt.attribute.id].values.find(v => v.id === opt.attribute_value.id)) {
              uniqueAttrs[opt.attribute.id].values.push(opt.attribute_value);
            }
          }
        });
      });

      attributes = Object.values(uniqueAttrs);

      // Load recommendations
      await loadRecommendations();

      // Render customizer UI
      renderCustomizer();

    } catch (error) {
      console.error('Error loading customizer:', error);
      container.innerHTML = '<p>Error loading product options. Please refresh the page.</p>';
    }
  }

  async function loadRecommendations() {
    try {
      const response = await fetch(`${APP_URL}/api/products/${encodeURIComponent(productId)}/recommendations`);

      if (!response.ok) {
        recommendations = [];
        return;
      }

      const data = await response.json();
      recommendations = data || [];

      // Fetch variants for each recommended product
      for (const rec of recommendations) {
        const product = rec.recommended_product;
        if (product && product.shopify_product_id) {
          const handle = product.handle || product.shopify_handle;
          await fetchProductVariants(product.shopify_product_id, product.id, handle);
          productDataCache[product.id] = {
            handle: handle,
            shopify_product_id: product.shopify_product_id
          };
        }
      }
    } catch (error) {
      console.error('Error loading recommendations:', error);
      recommendations = [];
    }
  }

  async function fetchProductVariants(shopifyProductId, internalProductId, productHandle) {
    try {
      const response = await fetch(`${APP_URL}/api/products/${encodeURIComponent(shopifyProductId)}/variants`);
      if (response.ok) {
        const variants = await response.json();

        // Also fetch Shopify product to get first variant ID for fallback mode
        let shopifyFallbackVariantId = null;
        if (productHandle) {
          try {
            console.log(`[Recommendation] Fetching Shopify product for fallback: /products/${productHandle}.js`);
            const shopifyResponse = await fetch(`/products/${productHandle}.js`);
            if (shopifyResponse.ok) {
              const shopifyProduct = await shopifyResponse.json();
              shopifyFallbackVariantId = shopifyProduct.variants?.[0]?.id;
              console.log(`[Recommendation] Fallback variant ID for ${productHandle}:`, shopifyFallbackVariantId);
            } else {
              console.warn(`[Recommendation] Failed to fetch product ${productHandle}:`, shopifyResponse.status);
            }
          } catch (e) {
            console.warn('[Recommendation] Could not fetch Shopify product for fallback:', e);
          }
        } else {
          console.warn('[Recommendation] No product handle provided for fallback variant fetch');
        }

        recommendationVariantsCache[internalProductId] = {
          variants: variants || [],
          shopifyProductId: shopifyProductId,
          shopifyFallbackVariantId: shopifyFallbackVariantId
        };
      } else {
        recommendationVariantsCache[internalProductId] = {
          variants: [],
          shopifyProductId: shopifyProductId,
          shopifyFallbackVariantId: null
        };
      }
    } catch (error) {
      console.error('Error fetching variants:', error);
      recommendationVariantsCache[internalProductId] = {
        variants: [],
        shopifyProductId: shopifyProductId,
        shopifyFallbackVariantId: null
      };
    }
  }

  function renderCustomizer() {
    const html = `
      <div class="unlimited-customizer__content">
        <h3 class="unlimited-customizer__title">Customize Your Product</h3>

        <div class="unlimited-customizer__options">
          ${attributes.map(attr => `
            <div class="unlimited-option" data-attribute-id="${attr.id}">
              <label class="unlimited-option__label">
                ${attr.name}
              </label>

              <select class="unlimited-option__select" data-attribute-id="${attr.id}">
                <option value="">Choose ${attr.name}</option>
                ${attr.values.map(value => `
                  <option value="${value.id}">${value.value}</option>
                `).join('')}
              </select>

              <div class="unlimited-option__preview" style="display: none;">
                <img class="unlimited-option__image" src="" alt="">
              </div>
            </div>
          `).join('')}
        </div>

        <div class="unlimited-customizer__variant-info" style="display: none;">
          <div class="unlimited-variant-price"></div>
          <div class="unlimited-variant-sku" style="display: none;"></div>
        </div>

        ${recommendations.length > 0 ? `
          <div class="unlimited-recommendations">
            <h4 class="unlimited-recommendations__title">You May Also Like</h4>
            <div class="unlimited-recommendations__grid">
              ${recommendations.map(rec => {
                const product = rec.recommended_product;
                if (!product) return '';

                const imageUrl = product.featuredImage?.url || product.image_url || '';

                // Get the first variant's price as base price
                const cachedData = recommendationVariantsCache[product.id];
                const firstVariant = cachedData?.variants?.[0];
                const price = firstVariant?.price ? `$${firstVariant.price}` : '';

                return `
                  <div class="unlimited-recommendation-item" data-product-id="${product.id}">
                    <input
                      type="checkbox"
                      class="unlimited-recommendation-checkbox"
                      id="rec-${product.id}"
                      data-product-id="${product.id}"
                      data-product-name="${product.title}"
                    >
                    <label for="rec-${product.id}" class="unlimited-recommendation-label">
                      ${imageUrl ? `
                        <img src="${imageUrl}" alt="${product.title}" class="unlimited-recommendation-image">
                      ` : `
                        <div class="unlimited-recommendation-image unlimited-recommendation-placeholder">
                          <span>No Image</span>
                        </div>
                      `}
                      <div class="unlimited-recommendation-info">
                        <div class="unlimited-recommendation-name">${product.title}</div>
                        ${price ? `<div class="unlimited-recommendation-price">${price}</div>` : ''}
                      </div>
                    </label>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        ` : ''}

        <div class="unlimited-customizer__actions">
          <button type="button" class="unlimited-buy-now btn btn-primary" disabled>
            Select All Options
          </button>
          <button type="button" class="unlimited-add-to-cart btn btn-secondary" disabled style="display: none;">
            Add to Cart (Preview)
          </button>
        </div>
      </div>
    `;

    container.innerHTML = html;
    attachEventListeners();
  }

  function attachEventListeners() {
    // Dropdown change handlers
    const selects = container.querySelectorAll('.unlimited-option__select');
    selects.forEach(select => {
      select.addEventListener('change', function() {
        const attrId = this.dataset.attributeId;
        const valueId = this.value;

        if (valueId) {
          selectedOptions[attrId] = valueId;

          // Show image preview
          const attr = attributes.find(a => a.id === attrId);
          const value = attr?.values.find(v => v.id === valueId);
          const preview = this.closest('.unlimited-option').querySelector('.unlimited-option__preview');
          const previewImg = preview.querySelector('.unlimited-option__image');

          if (value?.image_url) {
            previewImg.src = value.image_url;
            previewImg.alt = value.value;
            preview.style.display = 'block';
          } else {
            preview.style.display = 'none';
          }
        } else {
          delete selectedOptions[attrId];
        }

        updateVariant();
      });
    });

    // Recommendation checkbox handlers
    const recCheckboxes = container.querySelectorAll('.unlimited-recommendation-checkbox');
    recCheckboxes.forEach(checkbox => {
      checkbox.addEventListener('change', function() {
        const productId = this.dataset.productId;

        if (this.checked) {
          selectedRecommendations.add(productId);
        } else {
          selectedRecommendations.delete(productId);
        }

        updateVariant();
        updateRecommendationPreview();
      });
    });

    // Function to show what options will be selected for recommendations
    function updateRecommendationPreview() {
      const previewContainer = container.querySelector('.unlimited-bundle-preview');

      if (selectedRecommendations.size === 0) {
        if (previewContainer) {
          previewContainer.style.display = 'none';
        }
        return;
      }

      if (!previewContainer) {
        const previewDiv = document.createElement('div');
        previewDiv.className = 'unlimited-bundle-preview';
        const actionsSection = container.querySelector('.unlimited-customizer__actions');
        actionsSection.parentNode.insertBefore(previewDiv, actionsSection);
      }

      const preview = container.querySelector('.unlimited-bundle-preview');
      const mainSelections = getMainProductSelections();

      let previewHTML = `
        <div class="unlimited-bundle-preview__title">Bundle Items (${selectedRecommendations.size + 1} products):</div>
        <div class="unlimited-bundle-preview__items">
          <div class="unlimited-bundle-preview__item unlimited-bundle-preview__item--main">
            <strong>Main Product:</strong> Selected options will be added
          </div>
      `;

      selectedRecommendations.forEach(productId => {
        const cachedData = recommendationVariantsCache[productId];
        const recVariants = cachedData?.variants || [];
        const recommendation = recommendations.find(r => r.recommended_product.id === productId);
        const productName = recommendation?.recommended_product?.title || 'Recommended Product';

        if (recVariants.length === 0) {
          previewHTML += `
            <div class="unlimited-bundle-preview__item unlimited-bundle-preview__item--error">
              <strong>${productName}:</strong> <span class="unlimited-error">No variants available</span>
            </div>
          `;
          return;
        }

        const recAttributes = extractAttributes(recVariants);
        const preFilledSelections = {};
        const selectionDetails = [];

        recAttributes.forEach(attr => {
          const matchingMainSelection = Object.values(mainSelections).find(sel =>
            sel.attrName && attr.name &&
            sel.attrName.toLowerCase() === attr.name.toLowerCase()
          );

          let selectedValueText = '';
          let matchType = '';

          if (matchingMainSelection) {
            const matchedValueId = findMatchingValue(
              { valueText: matchingMainSelection.valueText },
              attr.values
            );

            if (matchedValueId) {
              preFilledSelections[attr.id] = matchedValueId;
              const matchedValue = attr.values.find(v => v.id === matchedValueId);
              selectedValueText = matchedValue?.value || '';

              if (matchedValue?.value.toLowerCase() === matchingMainSelection.valueText.toLowerCase()) {
                matchType = 'exact';
              } else {
                matchType = 'nearest';
              }
            }
          } else {
            const defaultValue = attr.values.find(v => v.is_default);
            if (defaultValue) {
              preFilledSelections[attr.id] = defaultValue.id;
              selectedValueText = defaultValue.value;
              matchType = 'default';
            }
          }

          if (selectedValueText) {
            selectionDetails.push({
              attrName: attr.name,
              value: selectedValueText,
              matchType: matchType
            });
          }
        });

        const matchedVariant = recVariants.find(variant => {
          return variant.variant_options?.every(opt =>
            preFilledSelections[opt.attribute.id] === opt.attribute_value.id
          );
        });

        if (matchedVariant) {
          previewHTML += `
            <div class="unlimited-bundle-preview__item unlimited-bundle-preview__item--success">
              <strong>${productName}:</strong>
              <div class="unlimited-bundle-preview__options">
                ${selectionDetails.map(detail => `
                  <span class="unlimited-bundle-option">
                    ${detail.attrName}: ${detail.value}
                    ${detail.matchType === 'exact' ? '<span class="unlimited-match-badge">✓</span>' : ''}
                    ${detail.matchType === 'nearest' ? '<span class="unlimited-match-badge unlimited-match-badge--nearest">~</span>' : ''}
                    ${detail.matchType === 'default' ? '<span class="unlimited-match-badge unlimited-match-badge--default">default</span>' : ''}
                  </span>
                `).join('')}
              </div>
            </div>
          `;
        } else {
          previewHTML += `
            <div class="unlimited-bundle-preview__item unlimited-bundle-preview__item--error">
              <strong>${productName}:</strong> <span class="unlimited-error">No matching variant found</span>
            </div>
          `;
        }
      });

      previewHTML += `
        </div>
        <div class="unlimited-bundle-preview__note">
          <small>✓ = Exact match | ~ = Nearest match | default = Using default value</small>
        </div>
      `;

      preview.innerHTML = previewHTML;
      preview.style.display = 'block';
    }

    // Buy Now button (primary action)
    const buyNowBtn = container.querySelector('.unlimited-buy-now');
    buyNowBtn.addEventListener('click', buyNow);

    // Add to cart button (secondary/hidden)
    const addToCartBtn = container.querySelector('.unlimited-add-to-cart');
    if (addToCartBtn) {
      addToCartBtn.addEventListener('click', addToCart);
    }
  }

  function updateVariant() {
    const variantInfo = container.querySelector('.unlimited-customizer__variant-info');
    const priceEl = container.querySelector('.unlimited-variant-price');
    const skuEl = container.querySelector('.unlimited-variant-sku');
    const buyNowBtn = container.querySelector('.unlimited-buy-now');
    const addToCartBtn = container.querySelector('.unlimited-add-to-cart');

    // Check if all options selected
    const allSelected = attributes.every(attr => selectedOptions[attr.id]);

    if (allSelected) {
      // Find matching variant
      const match = variants.find(variant => {
        return variant.variant_options?.every(opt =>
          selectedOptions[opt.attribute.id] === opt.attribute_value.id
        );
      });

      selectedVariant = match || null;

      if (selectedVariant) {
        // Show variant info
        variantInfo.style.display = 'block';

        // Calculate bundle price if recommendations selected
        let totalPrice = parseFloat(selectedVariant.price);

        if (selectedRecommendations.size > 0) {
          const mainSelections = getMainProductSelections();
          let recommendationsPriceTotal = 0;

          selectedRecommendations.forEach(productId => {
            const cachedData = recommendationVariantsCache[productId];
            const recVariants = cachedData?.variants || [];

            if (recVariants.length > 0) {
              const recAttributes = extractAttributes(recVariants);
              const preFilledSelections = {};

              recAttributes.forEach(attr => {
                const matchingMainSelection = Object.values(mainSelections).find(sel =>
                  sel.attrName && attr.name &&
                  sel.attrName.toLowerCase() === attr.name.toLowerCase()
                );

                if (matchingMainSelection) {
                  const matchedValueId = findMatchingValue(
                    { valueText: matchingMainSelection.valueText },
                    attr.values
                  );
                  if (matchedValueId) {
                    preFilledSelections[attr.id] = matchedValueId;
                  }
                } else {
                  const defaultValue = attr.values.find(v => v.is_default);
                  if (defaultValue) {
                    preFilledSelections[attr.id] = defaultValue.id;
                  }
                }
              });

              const matchedVariant = recVariants.find(variant => {
                return variant.variant_options?.every(opt =>
                  preFilledSelections[opt.attribute.id] === opt.attribute_value.id
                );
              });

              if (matchedVariant && matchedVariant.price) {
                recommendationsPriceTotal += parseFloat(matchedVariant.price);
              }
            }
          });

          totalPrice += recommendationsPriceTotal;
          priceEl.innerHTML = `
            <div style="display: flex; flex-direction: column; gap: 4px;">
              <div style="font-size: 24px; font-weight: 700; color: #008060;">
                Bundle Total: $${totalPrice.toFixed(2)}
              </div>
              <div style="font-size: 12px; color: #666;">
                Main: $${selectedVariant.price} + ${selectedRecommendations.size} item${selectedRecommendations.size > 1 ? 's' : ''}: $${recommendationsPriceTotal.toFixed(2)}
              </div>
            </div>
          `;
        } else {
          priceEl.innerHTML = `<strong>Price:</strong> $${selectedVariant.price}`;
        }

        if (selectedVariant.sku) {
          skuEl.innerHTML = `<strong>SKU:</strong> ${selectedVariant.sku}`;
          skuEl.style.display = 'block';
        }

        // Enable buy now button with dynamic text
        buyNowBtn.disabled = false;

        if (selectedRecommendations.size > 0) {
          buyNowBtn.textContent = 'Buy Bundle Now';
        } else {
          buyNowBtn.textContent = 'Buy Now';
        }

        // Also enable add to cart if visible
        if (addToCartBtn) {
          addToCartBtn.disabled = false;
          addToCartBtn.textContent = selectedRecommendations.size > 0 ? 'Add Bundle to Cart' : 'Add to Cart';
        }
      } else {
        variantInfo.style.display = 'none';
        buyNowBtn.disabled = true;
        buyNowBtn.textContent = 'Variant Not Available';
        if (addToCartBtn) {
          addToCartBtn.disabled = true;
          addToCartBtn.textContent = 'Variant Not Available';
        }
      }
    } else {
      variantInfo.style.display = 'none';
      buyNowBtn.disabled = true;
      buyNowBtn.textContent = 'Select All Options';
      if (addToCartBtn) {
        addToCartBtn.disabled = true;
        addToCartBtn.textContent = 'Select All Options';
      }
    }
  }

  // Get main product selections for smart pre-fill
  function getMainProductSelections() {
    const selections = {};

    attributes.forEach(attr => {
      const valueId = selectedOptions[attr.id];
      if (valueId) {
        const value = attr.values.find(v => v.id === valueId);
        if (value) {
          selections[attr.id] = {
            valueId: valueId,
            attrName: attr.name,
            valueText: value.value
          };
        }
      }
    });

    return selections;
  }

  // Find matching or nearest attribute value
  function findMatchingValue(mainSelection, availableValues) {
    if (!mainSelection || !availableValues || availableValues.length === 0) {
      return null;
    }

    // First try: Exact match by value text (case-insensitive)
    const exactMatch = availableValues.find(v =>
      v.value.toLowerCase() === mainSelection.valueText.toLowerCase()
    );
    if (exactMatch) return exactMatch.id;

    // Second try: Partial match (contains)
    const partialMatch = availableValues.find(v =>
      v.value.toLowerCase().includes(mainSelection.valueText.toLowerCase()) ||
      mainSelection.valueText.toLowerCase().includes(v.value.toLowerCase())
    );
    if (partialMatch) return partialMatch.id;

    // Third try: For numeric values, find nearest (e.g., carat weight)
    const mainValue = parseFloat(mainSelection.valueText);
    if (!isNaN(mainValue)) {
      const numericValues = availableValues
        .map(v => ({ ...v, numeric: parseFloat(v.value) }))
        .filter(v => !isNaN(v.numeric));

      if (numericValues.length > 0) {
        const nearest = numericValues.reduce((prev, curr) =>
          Math.abs(curr.numeric - mainValue) < Math.abs(prev.numeric - mainValue) ? curr : prev
        );
        return nearest.id;
      }
    }

    // No match found - return default or first
    const defaultValue = availableValues.find(v => v.is_default);
    return defaultValue?.id || null;
  }

  // Extract attributes from variants
  function extractAttributes(variants) {
    const uniqueAttrs = {};

    variants.forEach(variant => {
      variant.variant_options?.forEach(opt => {
        if (opt.attribute) {
          if (!uniqueAttrs[opt.attribute.id]) {
            uniqueAttrs[opt.attribute.id] = {
              ...opt.attribute,
              values: []
            };
          }
          if (!uniqueAttrs[opt.attribute.id].values.find(v => v.id === opt.attribute_value.id)) {
            uniqueAttrs[opt.attribute.id].values.push(opt.attribute_value);
          }
        }
      });
    });

    return Object.values(uniqueAttrs);
  }

  async function addToCart() {
    if (!selectedVariant) return;

    const addToCartBtn = container.querySelector('.unlimited-add-to-cart');
    addToCartBtn.disabled = true;
    addToCartBtn.textContent = 'Adding...';

    try {
      const itemsToAdd = [];

      console.log('[Bundle Add] Starting bundle add to cart', {
        mainVariant: selectedVariant.id,
        selectedRecommendations: Array.from(selectedRecommendations)
      });

      // Add main product via API first
      const apiResponse = await fetch(`${APP_URL}/api/cart/add-variant`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          variantId: selectedVariant.id,
          quantity: 1
        })
      });

      if (!apiResponse.ok) {
        const error = await apiResponse.json();
        throw new Error(error.error || 'Failed to prepare cart');
      }

      const apiData = await apiResponse.json();
      console.log('[Bundle Add] Main product API response:', apiData);

      // Handle fallback mode for custom variants
      if (apiData.fallback && apiData.variant) {
        const productVariantId = {{ product.variants.first.id }};
        console.log('[Bundle Add] Using fallback mode for main product');
        console.log('[Bundle Add] Shopify variant ID:', productVariantId);
        console.log('[Bundle Add] Properties from API:', apiData.variant.properties);
        console.log('[Bundle Add] DEBUG: _custom_variant_id from API:', apiData.variant.properties?._custom_variant_id);

        // Use properties from API response
        const properties = apiData.variant.properties || {
          '_Custom_Variant': 'Yes',
          '_Price': `$${apiData.variant.price}`
        };

        console.log('[Bundle Add] DEBUG: properties object to use:', properties);
        console.log('[Bundle Add] DEBUG: _custom_variant_id in properties:', properties._custom_variant_id);

        itemsToAdd.push({
          id: productVariantId,
          quantity: 1,
          properties: properties
        });

        console.log('[Bundle Add] Main product cart item:', itemsToAdd[itemsToAdd.length - 1]);
        console.log('[Bundle Add] DEBUG: _custom_variant_id in cart item:', itemsToAdd[itemsToAdd.length - 1].properties._custom_variant_id);
      } else if (apiData.success && apiData.shopifyVariantId) {
        // Direct Shopify variant (if synced)
        itemsToAdd.push({
          id: apiData.shopifyVariantId,
          quantity: 1
        });
      } else {
        console.error('[Bundle Add] Unexpected API response format:', apiData);
        throw new Error('Invalid API response format');
      }

      // Handle recommendations with smart pre-fill if any selected
      if (selectedRecommendations.size > 0) {
        const mainSelections = getMainProductSelections();
        console.log('[Bundle Add] Main selections:', mainSelections);

        const recommendationErrors = [];

        for (const productId of selectedRecommendations) {
          console.log('[Bundle Add] Processing recommendation:', productId);

          const cachedData = recommendationVariantsCache[productId];
          const recVariants = cachedData?.variants || [];

          console.log('[Bundle Add] Recommendation variants:', {
            productId,
            variantCount: recVariants.length,
            variants: recVariants
          });

          if (recVariants.length === 0) {
            recommendationErrors.push(`Product ${productId} has no variants`);
            continue;
          }

          // Extract attributes for this recommendation
          const recAttributes = extractAttributes(recVariants);

          // Build pre-filled selections
          const preFilledSelections = {};

          recAttributes.forEach(attr => {
            // Try to match with main product selections
            const matchingMainSelection = Object.values(mainSelections).find(sel =>
              sel.attrName && attr.name &&
              sel.attrName.toLowerCase() === attr.name.toLowerCase()
            );

            if (matchingMainSelection) {
              const matchedValueId = findMatchingValue(
                { valueText: matchingMainSelection.valueText },
                attr.values
              );

              if (matchedValueId) {
                preFilledSelections[attr.id] = matchedValueId;
              }
            } else {
              // No match, use default or first
              const defaultValue = attr.values.find(v => v.is_default);
              if (defaultValue) {
                preFilledSelections[attr.id] = defaultValue.id;
              }
            }
          });

          console.log('[Bundle Add] Pre-filled selections:', preFilledSelections);

          // Find matching variant from pre-filled selections
          const matchedVariant = recVariants.find(variant => {
            return variant.variant_options?.every(opt =>
              preFilledSelections[opt.attribute.id] === opt.attribute_value.id
            );
          });

          console.log('[Bundle Add] Matched variant:', matchedVariant);

          if (matchedVariant) {
            // Add recommendation via API
            try {
              const recApiResponse = await fetch(`${APP_URL}/api/cart/add-variant`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  variantId: matchedVariant.id,
                  quantity: 1
                })
              });

              if (recApiResponse.ok) {
                const recApiData = await recApiResponse.json();
                console.log('[Bundle Add] Recommendation API response:', recApiData);

                if (recApiData.fallback && recApiData.variant) {
                  // Fallback mode: use Shopify product's first variant with properties
                  const shopifyFallbackVariantId = cachedData?.shopifyFallbackVariantId;

                  if (shopifyFallbackVariantId) {
                    itemsToAdd.push({
                      id: shopifyFallbackVariantId,
                      quantity: 1,
                      properties: recApiData.variant.properties || {}
                    });
                    console.log('[Bundle Add] Added recommendation (fallback):', shopifyFallbackVariantId);
                  } else {
                    recommendationErrors.push(`No fallback variant for product ${productId}`);
                  }
                } else if (recApiData.success && recApiData.shopifyVariantId) {
                  // Direct Shopify variant
                  itemsToAdd.push({
                    id: recApiData.shopifyVariantId,
                    quantity: 1
                  });
                  console.log('[Bundle Add] Added recommendation (direct):', recApiData.shopifyVariantId);
                }
              } else {
                recommendationErrors.push(`API error for product ${productId}`);
              }
            } catch (err) {
              console.error('[Bundle Add] Error adding recommendation:', err);
              recommendationErrors.push(`Error adding product ${productId}: ${err.message}`);
            }
          } else {
            recommendationErrors.push(`No matching variant found for product ${productId}`);
          }
        }

        if (recommendationErrors.length > 0) {
          console.warn('[Bundle Add] Some recommendations failed:', recommendationErrors);
        }
      }

      console.log('[Bundle Add] Final items to add:', itemsToAdd);
      console.log('[Bundle Add] Number of items to add:', itemsToAdd.length);

      // Validate all items have valid IDs
      const invalidItems = itemsToAdd.filter(item => !item.id || item.id === '0' || item.id === 0);
      if (invalidItems.length > 0) {
        console.error('[Bundle Add] Invalid items detected:', invalidItems);
        throw new Error(`${invalidItems.length} items have invalid variant IDs`);
      }

      // Add all items to cart
      console.log('[Bundle Add] Sending request to /cart/add.js...');
      const response = await fetch('/cart/add.js', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ items: itemsToAdd })
      });

      console.log('[Bundle Add] Cart response status:', response.status);
      console.log('[Bundle Add] Cart response ok:', response.ok);

      const cartResponseText = await response.text();
      console.log('[Bundle Add] Raw cart response:', cartResponseText);

      let cartData;
      try {
        cartData = JSON.parse(cartResponseText);
      } catch (e) {
        console.error('[Bundle Add] Failed to parse cart response:', e);
        throw new Error('Invalid cart response format');
      }

      if (!response.ok) {
        console.error('[Bundle Add] Cart add error:', cartData);
        console.error('[Bundle Add] Error description:', cartData.description);
        console.error('[Bundle Add] Error message:', cartData.message);
        throw new Error(cartData.description || cartData.message || 'Failed to add to cart');
      }

      console.log('[Bundle Add] Cart add success:', cartData);
      console.log('[Bundle Add] Items actually added:', cartData.items?.length || 'unknown');

      // Success!
      addToCartBtn.textContent = `✓ Added ${itemsToAdd.length} Item${itemsToAdd.length > 1 ? 's' : ''} to Cart`;

      // Clear recommendation selections
      selectedRecommendations.clear();
      const checkboxes = container.querySelectorAll('.unlimited-recommendation-checkbox');
      checkboxes.forEach(cb => cb.checked = false);

      // Hide bundle preview
      const bundlePreview = container.querySelector('.unlimited-bundle-preview');
      if (bundlePreview) {
        bundlePreview.style.display = 'none';
      }

      // Trigger multiple cart update events to ensure refresh
      document.dispatchEvent(new CustomEvent('cart:updated'));
      document.dispatchEvent(new CustomEvent('cart:refresh'));

      // Trigger Shopify theme cart updates
      if (typeof window.Shopify !== 'undefined') {
        if (window.Shopify.onCartUpdate) {
          window.Shopify.onCartUpdate();
        }
      }

      // Try to refresh cart drawer/section if available
      fetch('/cart.js')
        .then(r => r.json())
        .then(cart => {
          document.dispatchEvent(new CustomEvent('cart:change', { detail: cart }));
          console.log('[Bundle Add] Cart refreshed:', cart);
        })
        .catch(e => console.error('[Bundle Add] Cart refresh error:', e));

      // Reset after 2 seconds
      setTimeout(() => {
        addToCartBtn.textContent = 'Add to Cart';
        addToCartBtn.disabled = false;
      }, 2000);
    } catch (error) {
      console.error('[Bundle Add] Error adding to cart:', error);
      addToCartBtn.textContent = 'Error - Try Again';

      alert(`Failed to add to cart: ${error.message}\n\nCheck console for details.`);

      setTimeout(() => {
        const hasRecommendations = selectedRecommendations.size > 0;
        addToCartBtn.textContent = hasRecommendations ? 'Add Bundle to Cart' : 'Add to Cart';
        addToCartBtn.disabled = false;
      }, 2000);
    }
  }

  async function buyNow() {
    if (!selectedVariant) return;

    const buyNowBtn = container.querySelector('.unlimited-buy-now');
    buyNowBtn.disabled = true;
    buyNowBtn.textContent = 'Creating checkout...';

    try {
      const itemsToProcess = [];

      console.log('[Buy Now] Starting checkout creation', {
        mainVariant: selectedVariant.id,
        selectedRecommendations: Array.from(selectedRecommendations)
      });

      // Add main product
      itemsToProcess.push({
        variantId: selectedVariant.id,
        quantity: 1
      });

      // Handle recommendations with smart pre-fill if any selected
      if (selectedRecommendations.size > 0) {
        const mainSelections = getMainProductSelections();
        console.log('[Buy Now] Main selections:', mainSelections);

        for (const productId of selectedRecommendations) {
          console.log('[Buy Now] Processing recommendation:', productId);

          const cachedData = recommendationVariantsCache[productId];
          const recVariants = cachedData?.variants || [];

          if (recVariants.length === 0) {
            console.warn('[Buy Now] Skipping recommendation - no variants:', productId);
            continue;
          }

          // Extract attributes for this recommendation
          const recAttributes = extractAttributes(recVariants);

          // Build pre-filled selections
          const preFilledSelections = {};

          recAttributes.forEach(attr => {
            // Try to match with main product selections
            const matchingMainSelection = Object.values(mainSelections).find(sel =>
              sel.attrName && attr.name &&
              sel.attrName.toLowerCase() === attr.name.toLowerCase()
            );

            if (matchingMainSelection) {
              const matchedValueId = findMatchingValue(
                { valueText: matchingMainSelection.valueText },
                attr.values
              );

              if (matchedValueId) {
                preFilledSelections[attr.id] = matchedValueId;
              }
            } else {
              // No match, use default or first
              const defaultValue = attr.values.find(v => v.is_default);
              if (defaultValue) {
                preFilledSelections[attr.id] = defaultValue.id;
              }
            }
          });

          // Find matching variant from pre-filled selections
          const matchedVariant = recVariants.find(variant => {
            return variant.variant_options?.every(opt =>
              preFilledSelections[opt.attribute.id] === opt.attribute_value.id
            );
          });

          if (matchedVariant) {
            itemsToProcess.push({
              variantId: matchedVariant.id,
              quantity: 1
            });
            console.log('[Buy Now] Added recommendation:', matchedVariant.id);
          } else {
            console.warn('[Buy Now] No matching variant for recommendation:', productId);
          }
        }
      }

      console.log('[Buy Now] Creating checkout with items:', itemsToProcess);

      // Call create-checkout API
      const response = await fetch(`${APP_URL}/api/cart/create-checkout`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ items: itemsToProcess })
      });

      console.log('[Buy Now] Checkout response status:', response.status);

      const data = await response.json();
      console.log('[Buy Now] Checkout response data:', data);

      if (!response.ok) {
        throw new Error(data.error || data.message || 'Failed to create checkout');
      }

      if (!data.success || !data.checkoutUrl) {
        throw new Error('No checkout URL returned');
      }

      console.log('[Buy Now] Redirecting to checkout:', data.checkoutUrl);

      // Clear recommendation selections
      selectedRecommendations.clear();
      const checkboxes = container.querySelectorAll('.unlimited-recommendation-checkbox');
      checkboxes.forEach(cb => cb.checked = false);

      // Hide bundle preview
      const bundlePreview = container.querySelector('.unlimited-bundle-preview');
      if (bundlePreview) {
        bundlePreview.style.display = 'none';
      }

      // Redirect to checkout
      window.location.href = data.checkoutUrl;

    } catch (error) {
      console.error('[Buy Now] Error creating checkout:', error);
      buyNowBtn.textContent = 'Error - Try Again';

      alert(`Failed to create checkout: ${error.message}\n\nCheck console for details.`);

      setTimeout(() => {
        const hasRecommendations = selectedRecommendations.size > 0;
        buyNowBtn.textContent = hasRecommendations ? 'Buy Bundle Now' : 'Buy Now';
        buyNowBtn.disabled = false;
      }, 2000);
    }
  }

  // Initialize
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', loadCustomizer);
  } else {
    loadCustomizer();
  }
})();

// Cart Checkout Interception for Custom Variants
(function() {
  console.log('[Cart Checkout] Initializing checkout interception');

  async function interceptCheckout(event) {
    try {
      // Get current cart
      const cartResponse = await fetch('/cart.js');
      const cart = await cartResponse.json();

      console.log('[Cart Checkout] Current cart:', cart);

      // Check if cart has custom variants (items with _custom_variant_id property)
      const customItems = cart.items.filter(item =>
        item.properties && item.properties._custom_variant_id
      );

      if (customItems.length === 0) {
        console.log('[Cart Checkout] No custom variants in cart, allowing normal checkout');
        return; // Allow normal checkout
      }

      // Prevent default checkout
      event.preventDefault();
      event.stopPropagation();

      console.log('[Cart Checkout] Found custom variants, intercepting checkout:', customItems);

      // Show loading state
      const button = event.target.closest('button, a, [type="submit"]');
      const originalText = button ? button.textContent : '';
      if (button) {
        button.textContent = 'Creating checkout...';
        button.disabled = true;
      }

      // Prepare items for create-checkout API
      const items = customItems.map(item => ({
        variantId: item.properties._custom_variant_id,
        quantity: item.quantity
      }));

      console.log('[Cart Checkout] Creating Draft Order with items:', items);

      // Call create-checkout API
      const response = await fetch(`${APP_URL}/api/cart/create-checkout`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ items })
      });

      const data = await response.json();
      console.log('[Cart Checkout] API response:', data);

      if (!response.ok) {
        throw new Error(data.error || data.message || 'Failed to create checkout');
      }

      if (!data.checkoutUrl) {
        throw new Error('No checkout URL returned');
      }

      // Redirect to Draft Order checkout
      console.log('[Cart Checkout] Redirecting to:', data.checkoutUrl);
      window.location.href = data.checkoutUrl;

    } catch (error) {
      console.error('[Cart Checkout] Error:', error);
      alert(`Failed to create checkout: ${error.message}\n\nPlease try again or contact support.`);

      // Restore button state
      if (button) {
        button.textContent = originalText;
        button.disabled = false;
      }
    }
  }

  function setupCheckoutInterception() {
    // Find all checkout buttons
    const checkoutButtons = document.querySelectorAll(
      'button[name="checkout"], ' +
      'input[name="checkout"], ' +
      '[href="/checkout"], ' +
      '[href*="/checkouts/"], ' +
      '.cart__checkout-button, ' +
      '.cart-drawer__checkout, ' +
      'button.checkout'
    );

    console.log('[Cart Checkout] Found checkout buttons:', checkoutButtons.length);

    checkoutButtons.forEach(button => {
      button.addEventListener('click', interceptCheckout, true); // Use capture phase
      console.log('[Cart Checkout] Attached listener to button:', button);
    });
  }

  // Run on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupCheckoutInterception);
  } else {
    setupCheckoutInterception();
  }

  // Also run when cart updates (for cart drawer themes)
  document.addEventListener('cart:updated', setupCheckoutInterception);

  // Run periodically to catch dynamically added buttons
  setInterval(setupCheckoutInterception, 2000);
})();
</script>

<style>
.unlimited-customizer {
  margin: 30px 0;
  padding: 20px;
  border: 1px solid #e5e5e5;
  border-radius: 8px;
  background: #fff;
}

.unlimited-customizer__loading {
  text-align: center;
  padding: 40px 20px;
  color: #666;
}

.unlimited-customizer__title {
  font-size: 20px;
  font-weight: 600;
  margin-bottom: 20px;
  color: #333;
}

.unlimited-customizer__options {
  margin-bottom: 20px;
}

.unlimited-option {
  margin-bottom: 20px;
}

.unlimited-option__label {
  display: block;
  font-weight: 600;
  margin-bottom: 8px;
  color: #333;
}

.unlimited-option__select {
  width: 100%;
  padding: 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 14px;
  background: white;
}

.unlimited-option__select:focus {
  outline: none;
  border-color: #008060;
}

.unlimited-option__preview {
  margin-top: 10px;
  padding: 10px;
  background: #f9f9f9;
  border-radius: 4px;
  text-align: center;
}

.unlimited-option__image {
  max-width: 80px;
  height: auto;
  border-radius: 4px;
}

.unlimited-customizer__variant-info {
  margin: 20px 0;
  padding: 15px;
  background: #f9f9f9;
  border-radius: 4px;
}

.unlimited-variant-price {
  font-size: 24px;
  color: #008060;
  margin-bottom: 8px;
}

.unlimited-variant-sku {
  font-size: 12px;
  color: #999;
}

.unlimited-customizer__actions {
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
}

.unlimited-buy-now {
  flex: 1;
  min-width: 200px;
  padding: 16px 32px;
  font-size: 18px;
  font-weight: 700;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  background: #008060;
  color: white;
  transition: all 0.2s;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  box-shadow: 0 2px 8px rgba(0, 128, 96, 0.3);
}

.unlimited-buy-now:hover:not(:disabled) {
  background: #006e52;
  box-shadow: 0 4px 12px rgba(0, 128, 96, 0.4);
  transform: translateY(-1px);
}

.unlimited-buy-now:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  background: #999;
  box-shadow: none;
  transform: none;
}

.unlimited-add-to-cart {
  flex: 0 0 auto;
  padding: 12px 20px;
  font-size: 14px;
  font-weight: 500;
  border: 2px solid #008060;
  border-radius: 4px;
  cursor: pointer;
  background: white;
  color: #008060;
  transition: all 0.2s;
}

.unlimited-add-to-cart:hover:not(:disabled) {
  background: #f0f7f5;
  border-color: #006e52;
  color: #006e52;
}

.unlimited-add-to-cart:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  border-color: #999;
  color: #999;
}

.spinner {
  width: 40px;
  height: 40px;
  margin: 0 auto;
  border: 4px solid #f3f3f3;
  border-top: 4px solid #008060;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Recommendations Styles */
.unlimited-recommendations {
  margin: 24px 0;
  padding: 20px;
  background: #f9f9f9;
  border-radius: 8px;
}

.unlimited-recommendations__title {
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 16px;
  color: #333;
}

.unlimited-recommendations__grid {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
}

.unlimited-recommendation-item {
  position: relative;
  flex: 0 0 150px;
}

.unlimited-recommendation-checkbox {
  position: absolute;
  top: 8px;
  left: 8px;
  width: 20px;
  height: 20px;
  cursor: pointer;
  z-index: 10;
  accent-color: #008060;
}

.unlimited-recommendation-label {
  display: block;
  cursor: pointer;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  overflow: hidden;
  transition: all 0.2s;
  background: white;
}

.unlimited-recommendation-label:hover {
  border-color: #008060;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

.unlimited-recommendation-item input:checked + .unlimited-recommendation-label {
  border-color: #008060;
  box-shadow: 0 4px 12px rgba(0, 128, 96, 0.3);
}

.unlimited-recommendation-image {
  width: 150px;
  height: 150px;
  object-fit: cover;
  display: block;
}

.unlimited-recommendation-placeholder {
  width: 150px;
  height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #f0f0f0;
  color: #999;
  font-size: 12px;
}

.unlimited-recommendation-info {
  padding: 8px;
  background: white;
}

.unlimited-recommendation-name {
  font-size: 12px;
  font-weight: 500;
  color: #333;
  line-height: 1.3;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}

.unlimited-recommendation-price {
  font-size: 13px;
  font-weight: 600;
  color: #008060;
  margin-top: 4px;
}

/* Bundle Preview Styles */
.unlimited-bundle-preview {
  margin: 20px 0;
  padding: 16px;
  background: #f0f7f4;
  border: 2px solid #008060;
  border-radius: 8px;
  display: none;
}

.unlimited-bundle-preview__title {
  font-size: 15px;
  font-weight: 600;
  color: #006e52;
  margin-bottom: 12px;
}

.unlimited-bundle-preview__items {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.unlimited-bundle-preview__item {
  padding: 10px;
  background: white;
  border-radius: 6px;
  border-left: 3px solid #ddd;
}

.unlimited-bundle-preview__item--main {
  border-left-color: #008060;
}

.unlimited-bundle-preview__item--success {
  border-left-color: #28a745;
}

.unlimited-bundle-preview__item--error {
  border-left-color: #dc3545;
  background: #fff5f5;
}

.unlimited-bundle-preview__options {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 6px;
}

.unlimited-bundle-option {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: #f8f9fa;
  border-radius: 4px;
  font-size: 12px;
  color: #495057;
}

.unlimited-match-badge {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #28a745;
  color: white;
  font-size: 10px;
  font-weight: 600;
}

.unlimited-match-badge--nearest {
  background: #ffc107;
  color: #333;
}

.unlimited-match-badge--default {
  background: #6c757d;
  color: white;
  width: auto;
  padding: 2px 6px;
  border-radius: 10px;
  font-size: 9px;
}

.unlimited-error {
  color: #dc3545;
  font-weight: 500;
}

.unlimited-bundle-preview__note {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid #dee2e6;
  color: #6c757d;
  font-size: 11px;
}

@media (max-width: 768px) {
  .unlimited-recommendations__grid {
    justify-content: center;
  }

  .unlimited-bundle-preview__options {
    flex-direction: column;
  }
}
</style>
