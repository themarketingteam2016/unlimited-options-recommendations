{% comment %}
  Product Recommendations Bundle Widget
  Displays recommended products with multi-select and bulk add to cart

  IMPORTANT: Position this block ABOVE the "Add to Cart" button in your theme for best UX
{% endcomment %}

<div id="unlimited-recommendations-{{ block.id }}" class="unlimited-recommendations" {{ block.shopify_attributes }}>
  <div id="recommendations-root"></div>
</div>

<!-- Variation Selection Modal -->
<div id="variation-modal-{{ block.id }}" class="unlimited-variation-modal" style="display: none;">
  <div class="unlimited-modal-overlay"></div>
  <div class="unlimited-modal-content">
    <div class="unlimited-modal-header">
      <h3 id="modal-title-{{ block.id }}">Confirm Bundle Selection</h3>
      <button class="unlimited-modal-close">&times;</button>
    </div>
    <div class="unlimited-modal-body" id="modal-body-{{ block.id }}">
      <!-- Dynamic content will be inserted here -->
    </div>
    <div class="unlimited-modal-footer">
      <button class="unlimited-modal-cancel">Cancel</button>
      <button class="unlimited-modal-confirm" id="modal-confirm-btn-{{ block.id }}">Confirm & Add to Cart</button>
    </div>
  </div>
</div>

<script>
  (function() {
    const productId = 'gid://shopify/Product/{{ product.id }}';
    const apiUrl = 'https://unlimtited-options-recommendations.vercel.app';
    const blockId = '{{ block.id }}';

    const container = document.getElementById('unlimited-recommendations-' + blockId);
    const root = container.querySelector('#recommendations-root');
    const modal = document.getElementById('variation-modal-' + blockId);
    const modalBody = document.getElementById('modal-body-' + blockId);

    let selectedProducts = new Set();
    let productVariantsCache = {};
    let productDataCache = {}; // Store product handles and other data
    let selectedVariants = {};

    // Show loading state
    root.innerHTML = '<div style="text-align:center;padding:40px;color:#666;">Loading recommendations...</div>';

    async function loadRecommendations() {
      try {
        console.log('Loading recommendations for product:', productId);

        const response = await fetch(`${apiUrl}/api/products/${encodeURIComponent(productId)}/recommendations`);

        if (!response.ok) {
          if (response.status === 404) {
            root.style.display = 'none';
            return;
          }
          throw new Error('Failed to fetch recommendations');
        }

        const recommendations = await response.json();

        if (!recommendations || recommendations.length === 0) {
          root.style.display = 'none';
          return;
        }

        // Fetch variants and cache product data for each recommended product
        for (const rec of recommendations) {
          const product = rec.recommended_product;
          if (product && product.shopify_product_id) {
            await fetchProductVariants(product.shopify_product_id, product.id);
            // Cache product data
            productDataCache[product.id] = {
              handle: product.handle || product.shopify_handle,
              shopify_product_id: product.shopify_product_id
            };
          }
        }

        renderRecommendations(recommendations);

      } catch (error) {
        console.error('Error loading recommendations:', error);
        root.style.display = 'none';
      }
    }

    async function fetchProductVariants(shopifyProductId, internalProductId) {
      try {
        const response = await fetch(`${apiUrl}/api/products/${encodeURIComponent(shopifyProductId)}/variants`);
        if (response.ok) {
          const variants = await response.json();
          productVariantsCache[internalProductId] = variants || [];
        } else {
          productVariantsCache[internalProductId] = [];
        }
      } catch (error) {
        console.error('Error fetching variants:', error);
        productVariantsCache[internalProductId] = [];
      }
    }

    async function getDefaultVariantId(internalProductId) {
      try {
        // Get product handle from cache
        const productInfo = productDataCache[internalProductId];
        if (!productInfo || !productInfo.handle) {
          console.error('No product handle found for', internalProductId);
          return null;
        }

        console.log(`Fetching default variant for ${internalProductId}, handle: ${productInfo.handle}`);

        // Fetch the product from Shopify to get its default variant
        const response = await fetch(`/products/${productInfo.handle}.js`);
        if (response.ok) {
          const productData = await response.json();
          // Return the first variant ID (default variant)
          if (productData.variants && productData.variants.length > 0) {
            console.log(`Found default variant ID: ${productData.variants[0].id}`);
            return productData.variants[0].id;
          }
        }
        return null;
      } catch (error) {
        console.error('Error fetching default variant:', error);
        return null;
      }
    }

    function getStartingPrice(productId) {
      const variants = productVariantsCache[productId] || [];
      if (variants.length === 0) return null;

      const prices = variants.map(v => parseFloat(v.price)).filter(p => !isNaN(p));
      if (prices.length === 0) return null;

      return Math.min(...prices).toFixed(2);
    }

    function renderRecommendations(recommendations) {
      const html = `
        <div class="unlimited-recommendations-widget">
          <div class="unlimited-bundle-header">
            <h3 class="unlimited-recommendations-title">You May Also Like</h3>
            <p class="unlimited-recommendations-subtitle">Select products to add them to your bundle</p>
          </div>

          <div class="unlimited-recommendations-grid">
            <!-- Recommended Products Only (Main product removed) -->
            ${recommendations.map(rec => {
              const product = rec.recommended_product;
              if (!product) return '';

              const imageUrl = product.featuredImage?.url || product.image_url || '';
              const productUrl = `/products/${product.handle || ''}`;
              const startingPrice = getStartingPrice(product.id);
              const hasVariants = (productVariantsCache[product.id] || []).length > 0;

              return `
                <div class="unlimited-recommendation-card" data-product-id="${product.id}">
                  <div class="unlimited-recommendation-checkbox">
                    <input
                      type="checkbox"
                      id="product-${product.id}"
                      class="unlimited-product-checkbox"
                      data-product-id="${product.id}"
                      data-product-name="${product.title}"
                      data-has-variants="${hasVariants}"
                    >
                    <label for="product-${product.id}"></label>
                  </div>

                  <a href="${productUrl}" class="unlimited-recommendation-link">
                    ${imageUrl ? `
                      <div class="unlimited-recommendation-image">
                        <img src="${imageUrl}" alt="${product.title}" loading="lazy">
                      </div>
                    ` : ''}
                    <div class="unlimited-recommendation-details">
                      <h4 class="unlimited-recommendation-product-title">${product.title}</h4>
                      ${rec.reason ? `
                        <p class="unlimited-recommendation-reason">${rec.reason}</p>
                      ` : ''}
                      <div class="unlimited-recommendation-price">
                        ${startingPrice ? `
                          <span class="unlimited-price-label">Starting from</span>
                          <span class="unlimited-price-value">$${startingPrice}</span>
                        ` : `<span class="unlimited-price-value">Select options</span>`}
                      </div>
                    </div>
                  </a>
                </div>
              `;
            }).join('')}
          </div>

          <!-- Bundle Items Preview Section (shown when items are selected) -->
          <div id="bundle-preview-${blockId}" class="unlimited-bundle-preview" style="display: none;">
            <h3 class="unlimited-bundle-preview-title">Bundle Items (<span id="bundle-count-${blockId}">0</span> products):</h3>
            <div id="bundle-items-${blockId}" class="unlimited-bundle-items-list">
              <!-- Dynamic bundle items will be inserted here -->
            </div>
          </div>

          <div class="unlimited-bundle-actions">
            <button
              class="unlimited-bulk-add-btn"
              id="bulk-add-btn-${blockId}"
            >
              Add to Cart
            </button>
          </div>
        </div>
      `;

      root.innerHTML = html;

      // Attach event listeners
      attachEventListeners();
    }

    function attachEventListeners() {
      // Checkbox changes
      const checkboxes = root.querySelectorAll('.unlimited-product-checkbox');
      checkboxes.forEach(checkbox => {
        checkbox.addEventListener('change', handleCheckboxChange);
      });

      // Bulk add button
      const bulkBtn = document.getElementById(`bulk-add-btn-${blockId}`);
      if (bulkBtn) {
        bulkBtn.addEventListener('click', handleBulkAdd);
      }

      // Modal close buttons
      const closeBtn = modal.querySelector('.unlimited-modal-close');
      const cancelBtn = modal.querySelector('.unlimited-modal-cancel');
      const confirmBtn = modal.querySelector('.unlimited-modal-confirm');
      const overlay = modal.querySelector('.unlimited-modal-overlay');

      if (closeBtn) closeBtn.addEventListener('click', closeModal);
      if (cancelBtn) cancelBtn.addEventListener('click', closeModal);
      if (overlay) overlay.addEventListener('click', closeModal);
      if (confirmBtn) confirmBtn.addEventListener('click', confirmBulkAdd);
    }

    function handleCheckboxChange(e) {
      const productId = e.target.dataset.productId;

      if (e.target.checked) {
        selectedProducts.add(productId);
        // Auto-select variant if there are variants for this product
        autoSelectVariant(productId);
      } else {
        selectedProducts.delete(productId);
        delete selectedVariants[productId];
      }

      updateBundlePreview();
      updateButtonText();
    }

    // Auto-select variant based on main product selections
    function autoSelectVariant(productId) {
      const variants = productVariantsCache[productId] || [];
      if (variants.length === 0) return;

      // Get main product selections
      const mainSelections = getMainProductSelections();

      // Try to find a matching variant
      const matchedVariant = findBestMatchingVariant(variants, mainSelections);

      if (matchedVariant) {
        selectedVariants[productId] = matchedVariant;
        console.log(`Auto-selected variant for product ${productId}:`, matchedVariant);
      }
    }

    // Find best matching variant based on main product selections
    function findBestMatchingVariant(variants, mainSelections) {
      if (variants.length === 0) return null;

      // Try to find exact match
      for (const variant of variants) {
        let matchCount = 0;
        const totalOptions = variant.variant_options?.length || 0;

        variant.variant_options?.forEach(opt => {
          const mainSelection = Object.values(mainSelections).find(sel =>
            sel.attrName && opt.attribute?.name &&
            sel.attrName.toLowerCase() === opt.attribute.name.toLowerCase()
          );

          if (mainSelection && mainSelection.valueText) {
            const optValue = opt.attribute_value?.value || '';
            if (optValue.toLowerCase() === mainSelection.valueText.toLowerCase()) {
              matchCount++;
            }
          }
        });

        // If all options match, return this variant
        if (matchCount === totalOptions && totalOptions > 0) {
          return variant;
        }
      }

      // Return first variant with default values if available
      const variantWithDefaults = variants.find(v =>
        v.variant_options?.every(opt => opt.attribute_value?.is_default)
      );

      return variantWithDefaults || variants[0];
    }

    function updateBundlePreview() {
      const bundlePreview = document.getElementById(`bundle-preview-${blockId}`);
      const bundleItems = document.getElementById(`bundle-items-${blockId}`);
      const bundleCount = document.getElementById(`bundle-count-${blockId}`);

      if (!bundlePreview || !bundleItems || !bundleCount) return;

      if (selectedProducts.size === 0) {
        bundlePreview.style.display = 'none';
        return;
      }

      bundlePreview.style.display = 'block';
      bundleCount.textContent = selectedProducts.size;

      // Render bundle items
      const itemsHTML = Array.from(selectedProducts).map(productId => {
        const checkbox = root.querySelector(`input[data-product-id="${productId}"]`);
        const productName = checkbox?.dataset.productName || 'Product';
        const variant = selectedVariants[productId];

        const optionsHTML = variant?.variant_options?.map(opt => {
          const attrName = opt.attribute?.name || '';
          const valueName = opt.attribute_value?.value || '';
          const matchStatus = checkMatchStatus(productId, opt);

          return `
            <div class="unlimited-bundle-option ${matchStatus}">
              <span class="unlimited-option-name">${attrName}:</span>
              <span class="unlimited-option-value">${valueName}</span>
              ${matchStatus === 'unlimited-match-exact' ? '<span class="unlimited-match-indicator">✓</span>' : ''}
              ${matchStatus === 'unlimited-match-nearest' ? '<span class="unlimited-match-indicator">~</span>' : ''}
            </div>
          `;
        }).join('') || '';

        return `
          <div class="unlimited-bundle-item" data-product-id="${productId}">
            <div class="unlimited-bundle-item-header">
              <h4 class="unlimited-bundle-item-name">${productName}</h4>
              <button class="unlimited-bundle-edit-btn" data-product-id="${productId}">Edit</button>
            </div>
            <div class="unlimited-bundle-item-options">
              ${variant ? optionsHTML : '<p class="unlimited-no-variant">Selected options will be added</p>'}
            </div>
            ${variant && variant.price ? `
              <div class="unlimited-bundle-item-price">$${variant.price}</div>
            ` : ''}
          </div>
        `;
      }).join('');

      bundleItems.innerHTML = itemsHTML;

      // Attach edit button listeners
      const editButtons = bundleItems.querySelectorAll('.unlimited-bundle-edit-btn');
      editButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
          const productId = e.target.dataset.productId;
          showVariantModal([productId]);
        });
      });
    }

    function checkMatchStatus(productId, variantOption) {
      const mainSelections = getMainProductSelections();

      const mainSelection = Object.values(mainSelections).find(sel =>
        sel.attrName && variantOption.attribute?.name &&
        sel.attrName.toLowerCase() === variantOption.attribute.name.toLowerCase()
      );

      if (!mainSelection) return '';

      const optValue = variantOption.attribute_value?.value || '';
      const mainValue = mainSelection.valueText || '';

      if (optValue.toLowerCase() === mainValue.toLowerCase()) {
        return 'unlimited-match-exact';
      }

      // Check for nearest match (numeric values)
      const optNumeric = parseFloat(optValue);
      const mainNumeric = parseFloat(mainValue);
      if (!isNaN(optNumeric) && !isNaN(mainNumeric)) {
        return 'unlimited-match-nearest';
      }

      return 'unlimited-match-default';
    }

    function updateButtonText() {
      const bulkBtn = document.getElementById(`bulk-add-btn-${blockId}`);

      if (bulkBtn) {
        if (selectedProducts.size === 0) {
          bulkBtn.textContent = 'Add to Cart';
        } else {
          bulkBtn.textContent = 'Add Bundle to Cart';
        }
      }
    }

    function handleBulkAdd() {
      if (selectedProducts.size === 0) return;

      // Always show confirmation modal with all bundle items (including main product)
      showBundleConfirmationModal();
    }

    function showBundleConfirmationModal() {
      // Build list of all products (selected bundle items)
      const allProductIds = Array.from(selectedProducts);

      showVariantModal(allProductIds, true); // true = confirmation mode
    }

    // Get selected attribute values from main product customizer
    function getMainProductSelections() {
      const mainCustomizer = document.querySelector('.unlimited-options-widget') ||
                             document.querySelector('.unlimited-customizer');
      if (!mainCustomizer) return {};

      const selections = {};
      const selects = mainCustomizer.querySelectorAll('.unlimited-dropdown, .unlimited-option__select');

      selects.forEach(select => {
        const attrId = select.dataset.attributeId;
        const valueId = select.value;

        if (attrId && valueId) {
          // Also get the attribute name and value text for matching
          const attrName = select.closest('.unlimited-option-group, .unlimited-option')?.querySelector('.unlimited-option-label, .unlimited-option__label')?.textContent?.trim();
          const valueText = select.options[select.selectedIndex]?.text;

          selections[attrId] = {
            valueId: valueId,
            attrName: attrName || '',
            valueText: valueText || ''
          };
        }
      });

      console.log('Main product selections:', selections);
      return selections;
    }

    // Listen for changes in main product customizer
    function setupMainProductListeners() {
      const mainCustomizer = document.querySelector('.unlimited-options-widget') ||
                             document.querySelector('.unlimited-customizer');
      if (!mainCustomizer) {
        // Retry after a short delay
        setTimeout(setupMainProductListeners, 500);
        return;
      }

      const selects = mainCustomizer.querySelectorAll('.unlimited-dropdown, .unlimited-option__select');

      selects.forEach(select => {
        select.addEventListener('change', () => {
          console.log('Main product option changed, updating bundle items...');
          // Re-select variants for all selected bundle products
          selectedProducts.forEach(productId => {
            autoSelectVariant(productId);
          });
          updateBundlePreview();
        });
      });

      console.log('Main product listeners set up successfully');
    }

    // Find matching or nearest attribute value
    function findMatchingValue(mainSelection, availableValues) {
      if (!mainSelection || !availableValues || availableValues.length === 0) {
        return null;
      }

      // First try: Exact match by value text (case-insensitive)
      const exactMatch = availableValues.find(v =>
        v.value.toLowerCase() === mainSelection.valueText.toLowerCase()
      );
      if (exactMatch) {
        console.log(`Exact match found: ${exactMatch.value}`);
        return exactMatch.id;
      }

      // Second try: Partial match (contains)
      const partialMatch = availableValues.find(v =>
        v.value.toLowerCase().includes(mainSelection.valueText.toLowerCase()) ||
        mainSelection.valueText.toLowerCase().includes(v.value.toLowerCase())
      );
      if (partialMatch) {
        console.log(`Partial match found: ${partialMatch.value}`);
        return partialMatch.id;
      }

      // Third try: For numeric values, find nearest (e.g., carat weight)
      const mainValue = parseFloat(mainSelection.valueText);
      if (!isNaN(mainValue)) {
        const numericValues = availableValues
          .map(v => ({ ...v, numeric: parseFloat(v.value) }))
          .filter(v => !isNaN(v.numeric));

        if (numericValues.length > 0) {
          const nearest = numericValues.reduce((prev, curr) =>
            Math.abs(curr.numeric - mainValue) < Math.abs(prev.numeric - mainValue) ? curr : prev
          );
          console.log(`Nearest numeric match found: ${nearest.value}`);
          return nearest.id;
        }
      }

      // No match found - return first available or default
      const defaultValue = availableValues.find(v => v.is_default);
      if (defaultValue) {
        console.log(`Using default value: ${defaultValue.value}`);
        return defaultValue.id;
      }

      console.log('No match found, returning null');
      return null;
    }

    function showVariantModal(productIds, isConfirmationMode = false) {
      // Update modal title
      const modalTitle = document.getElementById(`modal-title-${blockId}`);
      const confirmBtn = document.getElementById(`modal-confirm-btn-${blockId}`);

      if (modalTitle) {
        modalTitle.textContent = isConfirmationMode
          ? 'Confirm Bundle Selection'
          : 'Select Variations for Bundle';
      }

      if (confirmBtn) {
        confirmBtn.textContent = isConfirmationMode
          ? 'Confirm & Add to Cart'
          : 'Add Selected to Cart';
      }

      // Get main product selections for smart pre-fill
      const mainSelections = getMainProductSelections();

      const instructionText = isConfirmationMode
        ? `Review and confirm your bundle selection (${productIds.length} product${productIds.length > 1 ? 's' : ''})`
        : (productIds.length > 1
          ? `Please select options for all ${productIds.length} products in your bundle.`
          : 'Please select options for this product.');

      const modalContent = `
        <div class="unlimited-modal-instruction ${isConfirmationMode ? 'unlimited-confirmation-mode' : ''}">
          <p style="font-size: 16px; font-weight: 600;">${instructionText}</p>
          ${isConfirmationMode ? `
            <p style="color: #008060; margin-top: 8px; font-size: 14px;">
              ✓ Options auto-matched from main product | You can edit any option below
            </p>
          ` : (Object.keys(mainSelections).length > 0 ? `
            <p style="color: #008060; font-weight: 600; margin-top: 8px;">
              ✓ Pre-filled with your selections from the main product
            </p>
          ` : '')}
        </div>
        ${productIds.map(productId => {
          const variants = productVariantsCache[productId] || [];
          if (variants.length === 0) return '';

          // Extract attributes
          const attributes = extractAttributes(variants);
          const checkbox = root.querySelector(`input[data-product-id="${productId}"]`);
          const productName = checkbox?.dataset.productName || 'Product';

          return `
            <div class="unlimited-product-variant-section" data-product-id="${productId}">
              <h4 class="unlimited-variant-product-name">${productName}</h4>

              ${attributes.map(attr => {
                // Try to find matching value from main product
                const matchedValueId = Object.values(mainSelections).find(sel =>
                  sel.attrName && attr.name &&
                  sel.attrName.toLowerCase() === attr.name.toLowerCase()
                )?.valueText;

                const preSelectedValue = matchedValueId
                  ? findMatchingValue({ valueText: matchedValueId }, attr.values)
                  : (attr.values.find(v => v.is_default)?.id || '');

                // Determine match type for indicator
                const mainSelectionForAttr = Object.values(mainSelections).find(sel =>
                  sel.attrName && attr.name &&
                  sel.attrName.toLowerCase() === attr.name.toLowerCase()
                );

                const selectedValueObj = attr.values.find(v => v.id === preSelectedValue);
                let matchIndicator = '';
                if (mainSelectionForAttr && selectedValueObj) {
                  if (selectedValueObj.value.toLowerCase() === mainSelectionForAttr.valueText.toLowerCase()) {
                    matchIndicator = '<span class="unlimited-match-badge unlimited-exact">✓ Exact match</span>';
                  } else if (!isNaN(parseFloat(selectedValueObj.value)) && !isNaN(parseFloat(mainSelectionForAttr.valueText))) {
                    matchIndicator = '<span class="unlimited-match-badge unlimited-nearest">~ Nearest match</span>';
                  } else if (selectedValueObj.is_default) {
                    matchIndicator = '<span class="unlimited-match-badge unlimited-default">Default value</span>';
                  }
                }

                return `
                  <div class="unlimited-variant-option-group">
                    <div class="unlimited-variant-label-row">
                      <label class="unlimited-variant-label">${attr.name} <span class="unlimited-required">*</span></label>
                      ${matchIndicator}
                    </div>
                    <select class="unlimited-variant-select" data-product-id="${productId}" data-attribute-id="${attr.id}" required>
                      <option value="">Choose ${attr.name}</option>
                      ${attr.values.map(value => `
                        <option value="${value.id}" ${value.id === preSelectedValue ? 'selected' : ''}>${value.value}</option>
                      `).join('')}
                    </select>
                  </div>
                `;
              }).join('')}

              <div class="unlimited-variant-preview" ${isConfirmationMode ? 'style="display: block;"' : 'style="display: none;"'}>
                <div class="unlimited-variant-price"></div>
                <div class="unlimited-variant-stock"></div>
              </div>
            </div>
          `;
        }).join('')}
      `;

      modalBody.innerHTML = modalContent;

      // Attach variant selection listeners
      const selects = modalBody.querySelectorAll('.unlimited-variant-select');
      selects.forEach(select => {
        select.addEventListener('change', handleVariantSelection);
        // Trigger initial selection to show preview if pre-filled
        if (select.value) {
          select.dispatchEvent(new Event('change'));
        }
      });

      // Show modal
      modal.style.display = 'flex';
      document.body.style.overflow = 'hidden';
    }

    function extractAttributes(variants) {
      const uniqueAttrs = {};

      variants.forEach(variant => {
        variant.variant_options?.forEach(opt => {
          if (opt.attribute) {
            if (!uniqueAttrs[opt.attribute.id]) {
              uniqueAttrs[opt.attribute.id] = {
                ...opt.attribute,
                values: []
              };
            }
            if (!uniqueAttrs[opt.attribute.id].values.find(v => v.id === opt.attribute_value.id)) {
              uniqueAttrs[opt.attribute.id].values.push(opt.attribute_value);
            }
          }
        });
      });

      return Object.values(uniqueAttrs);
    }

    function handleVariantSelection(e) {
      const productId = e.target.dataset.productId;
      const variants = productVariantsCache[productId] || [];
      const section = modalBody.querySelector(`[data-product-id="${productId}"]`);

      if (!section) return;

      // Get all selected options for this product
      const selects = section.querySelectorAll('.unlimited-variant-select');
      const selectedOptions = {};

      selects.forEach(select => {
        const attrId = select.dataset.attributeId;
        const valueId = select.value;
        if (valueId) {
          selectedOptions[attrId] = valueId;
        }
      });

      // Find matching variant
      const matchedVariant = variants.find(variant => {
        return variant.variant_options?.every(opt =>
          selectedOptions[opt.attribute.id] === opt.attribute_value.id
        );
      });

      // Update preview
      const previewSection = section.querySelector('.unlimited-variant-preview');
      const priceEl = section.querySelector('.unlimited-variant-price');
      const stockEl = section.querySelector('.unlimited-variant-stock');

      if (matchedVariant) {
        selectedVariants[productId] = matchedVariant;
        previewSection.style.display = 'block';
        priceEl.textContent = `Price: $${matchedVariant.price}`;
        stockEl.textContent = matchedVariant.stock_quantity > 0
          ? `In Stock: ${matchedVariant.stock_quantity}`
          : 'Out of Stock';
        stockEl.style.color = matchedVariant.stock_quantity > 0 ? '#008060' : '#dc3545';
      } else {
        delete selectedVariants[productId];
        previewSection.style.display = 'none';
      }
    }

    function closeModal() {
      modal.style.display = 'none';
      document.body.style.overflow = 'auto';
      // Update bundle preview when modal closes
      updateBundlePreview();
    }

    async function confirmBulkAdd() {
      const confirmBtn = modal.querySelector('.unlimited-modal-confirm');
      const originalText = confirmBtn?.textContent || 'Add Selected to Cart';

      // Validate all products have variants selected
      const missingVariants = [];
      for (const productId of selectedProducts) {
        const variants = productVariantsCache[productId] || [];
        if (variants.length > 0 && !selectedVariants[productId]) {
          const checkbox = root.querySelector(`input[data-product-id="${productId}"]`);
          const productName = checkbox?.dataset.productName || 'Unknown product';
          missingVariants.push(productName);
        }
      }

      if (missingVariants.length > 0) {
        alert(`Please select variants for:\n\n${missingVariants.map(name => `• ${name}`).join('\n')}`);
        return;
      }

      if (confirmBtn) {
        confirmBtn.disabled = true;
        confirmBtn.textContent = 'Adding...';
      }

      try {
        const itemsToAdd = [];
        const failures = [];

        for (const productId of selectedProducts) {
          const variants = productVariantsCache[productId] || [];
          const checkbox = root.querySelector(`input[data-product-id="${productId}"]`);
          const productName = checkbox?.dataset.productName || 'Product';

          if (variants.length === 0) {
            console.warn(`No variants for product ${productId}`);
            failures.push({ product: productName, reason: 'No variants available' });
            continue;
          }

          let variantToAdd = selectedVariants[productId];

          // This should not happen now due to validation above
          if (!variantToAdd) {
            console.warn(`No variant selected for product ${productId}`);
            failures.push({ product: productName, reason: 'No variant selected' });
            continue;
          }

          // Check stock
          if (variantToAdd.stock_quantity <= 0) {
            failures.push({ product: productName, reason: 'Out of stock' });
            continue;
          }

          // Prepare variant for cart
          console.log(`Preparing variant for ${productName}:`, variantToAdd.id);

          try {
            const apiResponse = await fetch(`${apiUrl}/api/cart/add-variant`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                variantId: variantToAdd.id,
                quantity: 1
              })
            });

            if (!apiResponse.ok) {
              const error = await apiResponse.json().catch(() => ({ error: 'Unknown error' }));
              console.error(`Failed to prepare variant for ${productName}:`, error);
              failures.push({ product: productName, reason: error.error || `API error ${apiResponse.status}` });
              continue;
            }

            const apiData = await apiResponse.json();
            console.log(`API response for ${productName}:`, apiData);

            if (apiData.success && apiData.cartData) {
              itemsToAdd.push(apiData.cartData);
              console.log(`Successfully prepared ${productName} for cart`);
            } else if (apiData.fallback && apiData.variant) {
              // Fallback mode - use default variant with line item properties
              console.log(`Using fallback mode for ${productName}`, apiData.variant);

              // Get the product's default/first variant ID from Shopify using internal product ID
              const fallbackVariantId = await getDefaultVariantId(productId);

              if (fallbackVariantId) {
                // Build properties from variant options
                const properties = {};
                if (apiData.variant.options && Array.isArray(apiData.variant.options)) {
                  apiData.variant.options.forEach(opt => {
                    properties[opt.name] = opt.value;
                  });
                }

                if (apiData.variant.sku) {
                  properties['_SKU'] = apiData.variant.sku;
                }

                properties['_Custom_Variant'] = 'Yes';
                properties['_Price'] = String(apiData.variant.price);

                itemsToAdd.push({
                  id: fallbackVariantId,
                  quantity: 1,
                  properties: properties
                });

                console.log(`Added ${productName} using fallback mode with properties`, properties);
              } else {
                failures.push({ product: productName, reason: 'Could not find default variant for fallback' });
              }
            } else {
              failures.push({ product: productName, reason: 'API returned unsuccessful response' });
            }
          } catch (fetchError) {
            console.error(`Network error for ${productName}:`, fetchError);
            failures.push({ product: productName, reason: 'Network error' });
          }
        }

        console.log(`Items to add: ${itemsToAdd.length}, Failures: ${failures.length}`);

        if (itemsToAdd.length === 0) {
          const failureDetails = failures.map(f => `• ${f.product}: ${f.reason}`).join('\n');
          throw new Error(`Could not add any items to cart:\n\n${failureDetails}`);
        }

        // Show warnings if some items failed but others succeeded
        if (failures.length > 0) {
          console.warn('Some items could not be added:', failures);
          const failureMsg = failures.map(f => `• ${f.product}: ${f.reason}`).join('\n');
          alert(`Warning: Some items could not be added:\n\n${failureMsg}\n\nAdding ${itemsToAdd.length} item(s) to cart...`);
        }

        // Add all items to cart in one request
        console.log('Adding items to cart:', itemsToAdd);

        const cartResponse = await fetch('/cart/add.js', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ items: itemsToAdd })
        });

        console.log('Cart response status:', cartResponse.status);

        if (!cartResponse.ok) {
          const cartError = await cartResponse.json().catch(() => ({ description: 'Unknown error' }));
          console.error('Cart add error:', cartError);
          throw new Error(cartError.description || `Failed to add bundle to cart (status: ${cartResponse.status})`);
        }

        const cartData = await cartResponse.json();
        console.log('Cart add success:', cartData);

        // Success!
        closeModal();

        // Reset selections
        selectedProducts.clear();
        selectedVariants = {};

        const checkboxes = root.querySelectorAll('.unlimited-product-checkbox');
        checkboxes.forEach(cb => cb.checked = false);

        updateBundlePreview();
        updateButtonText();

        // Show success message
        const bulkBtn = document.getElementById(`bulk-add-btn-${blockId}`);
        if (bulkBtn) {
          bulkBtn.textContent = '✓ Added to Cart';
          bulkBtn.style.background = '#28a745';

          setTimeout(() => {
            bulkBtn.textContent = 'Add Selected to Cart';
            bulkBtn.style.background = '#008060';
          }, 2000);
        }

        // Trigger cart update
        document.dispatchEvent(new CustomEvent('cart:updated'));
        document.dispatchEvent(new CustomEvent('cart:refresh'));
        document.dispatchEvent(new CustomEvent('cart:changed'));
        document.dispatchEvent(new CustomEvent('product:added'));

        // jQuery events
        if (typeof jQuery !== 'undefined') {
          jQuery(document).trigger('cart.updated');
        }

        if (typeof window.Shopify !== 'undefined') {
          if (window.Shopify.onCartUpdate) {
            window.Shopify.onCartUpdate();
          }
          if (window.Shopify.onItemAdded) {
            window.Shopify.onItemAdded();
          }
        }

        // Refresh cart and update UI
        fetch('/cart.js')
          .then(r => r.json())
          .then(cart => {
            // Update cart count
            const cartCountElements = document.querySelectorAll('[data-cart-count], .cart-count, #CartCount, .cart-link__bubble, .cart-bubble__text-count');
            cartCountElements.forEach(el => {
              el.textContent = cart.item_count;
              if (cart.item_count > 0) {
                el.style.display = '';
                el.classList.remove('hidden');
              }
            });

            // Open cart drawer
            const cartDrawerComponent = document.querySelector('cart-drawer-component');
            if (cartDrawerComponent) {
              const dialog = cartDrawerComponent.querySelector('dialog');
              if (dialog && dialog.showModal) {
                dialog.showModal();
              } else {
                const cartButton = document.querySelector('cart-drawer-component button[aria-haspopup="dialog"]');
                if (cartButton) cartButton.click();
              }
            }
          })
          .catch(e => console.error('Cart refresh error:', e));

      } catch (error) {
        console.error('Error adding bundle to cart:', error);
        alert(`Failed to add bundle: ${error.message}`);
      } finally {
        if (confirmBtn) {
          confirmBtn.disabled = false;
          confirmBtn.textContent = originalText;
        }
      }
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        loadRecommendations();
        setupMainProductListeners();
      });
    } else {
      loadRecommendations();
      setupMainProductListeners();
    }
  })();
</script>

<style>
  .unlimited-recommendations {
    margin: 40px 0;
    padding: 0;
  }

  .unlimited-recommendations-widget {
    max-width: 100%;
  }

  .unlimited-bundle-header {
    margin-bottom: 24px;
    text-align: center;
  }

  .unlimited-recommendations-title {
    font-size: 28px;
    font-weight: 700;
    color: #202223;
    margin-bottom: 8px;
  }

  .unlimited-recommendations-subtitle {
    font-size: 14px;
    color: #6d7175;
    margin: 0;
  }

  .unlimited-recommendations-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 24px;
    margin-bottom: 24px;
  }

  @media (max-width: 768px) {
    .unlimited-recommendations-grid {
      grid-template-columns: 1fr;
      gap: 16px;
    }
  }

  .unlimited-recommendation-card {
    background: white;
    border: 2px solid #e3e5e7;
    border-radius: 12px;
    overflow: hidden;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    position: relative;
  }

  .unlimited-recommendation-card:hover {
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.12);
    transform: translateY(-4px);
    border-color: #008060;
  }

  .unlimited-recommendation-checkbox {
    position: absolute;
    top: 12px;
    left: 12px;
    z-index: 10;
  }

  .unlimited-recommendation-checkbox input[type="checkbox"] {
    width: 24px;
    height: 24px;
    cursor: pointer;
    accent-color: #008060;
  }

  .unlimited-recommendation-link {
    display: block;
    text-decoration: none;
    color: inherit;
  }

  .unlimited-recommendation-image {
    width: 100%;
    height: 250px;
    overflow: hidden;
    background: #f6f6f7;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .unlimited-recommendation-image img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.3s ease;
  }

  .unlimited-recommendation-card:hover .unlimited-recommendation-image img {
    transform: scale(1.05);
  }

  .unlimited-recommendation-details {
    padding: 16px;
  }

  .unlimited-recommendation-product-title {
    font-size: 16px;
    font-weight: 600;
    color: #202223;
    margin: 0 0 8px 0;
    line-height: 1.4;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .unlimited-recommendation-reason {
    font-size: 13px;
    color: #6d7175;
    margin: 0 0 12px 0;
    line-height: 1.4;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .unlimited-recommendation-price {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .unlimited-price-label {
    font-size: 12px;
    color: #6d7175;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .unlimited-price-value {
    font-size: 20px;
    font-weight: 700;
    color: #008060;
  }

  .unlimited-bundle-actions {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 24px 0;
    margin-top: 24px;
  }

  .unlimited-bulk-add-btn {
    padding: 16px 48px;
    border: none;
    background: #008060;
    color: white;
    font-size: 16px;
    font-weight: 700;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s;
    text-transform: uppercase;
    letter-spacing: 1px;
    box-shadow: 0 4px 12px rgba(0, 128, 96, 0.3);
  }

  .unlimited-bulk-add-btn:hover {
    background: #006e52;
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 128, 96, 0.4);
  }

  /* Modal Styles */
  .unlimited-variation-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .unlimited-modal-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
  }

  .unlimited-modal-content {
    position: relative;
    background: white;
    border-radius: 12px;
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
  }

  .unlimited-modal-header {
    padding: 24px;
    border-bottom: 1px solid #e3e5e7;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .unlimited-modal-header h3 {
    margin: 0;
    font-size: 20px;
    font-weight: 700;
    color: #202223;
  }

  .unlimited-modal-close {
    background: none;
    border: none;
    font-size: 32px;
    color: #6d7175;
    cursor: pointer;
    padding: 0;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
  }

  .unlimited-modal-close:hover {
    color: #202223;
  }

  .unlimited-modal-body {
    padding: 24px;
    overflow-y: auto;
    flex: 1;
  }

  .unlimited-modal-instruction {
    background: #e8f5f1;
    border-left: 4px solid #008060;
    padding: 16px;
    margin-bottom: 24px;
    border-radius: 6px;
  }

  .unlimited-modal-instruction p {
    margin: 0;
    font-size: 14px;
    color: #202223;
    line-height: 1.5;
  }

  .unlimited-modal-instruction.unlimited-confirmation-mode {
    background: linear-gradient(135deg, #e8f5f1 0%, #f0f9f6 100%);
    border-left-width: 6px;
  }

  .unlimited-variant-label-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }

  .unlimited-match-badge {
    font-size: 12px;
    padding: 4px 10px;
    border-radius: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .unlimited-match-badge.unlimited-exact {
    background: #e8f5f1;
    color: #008060;
    border: 1px solid #008060;
  }

  .unlimited-match-badge.unlimited-nearest {
    background: #fff4e5;
    color: #ff9800;
    border: 1px solid #ff9800;
  }

  .unlimited-match-badge.unlimited-default {
    background: #f0f0f0;
    color: #6d7175;
    border: 1px solid #c9cccf;
  }

  .unlimited-product-variant-section {
    margin-bottom: 32px;
    padding-bottom: 32px;
    border-bottom: 1px solid #e3e5e7;
  }

  .unlimited-product-variant-section:last-child {
    margin-bottom: 0;
    padding-bottom: 0;
    border-bottom: none;
  }

  .unlimited-variant-product-name {
    font-size: 18px;
    font-weight: 600;
    color: #202223;
    margin: 0 0 16px 0;
  }

  .unlimited-variant-option-group {
    margin-bottom: 16px;
  }

  .unlimited-variant-label {
    display: block;
    font-weight: 600;
    color: #202223;
    margin-bottom: 8px;
    font-size: 14px;
  }

  .unlimited-required {
    color: #dc3545;
    margin-left: 2px;
  }

  .unlimited-variant-select {
    width: 100%;
    padding: 10px 14px;
    border: 2px solid #c9cccf;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    color: #202223;
    background: white;
    cursor: pointer;
    transition: all 0.2s;
  }

  .unlimited-variant-select:hover {
    border-color: #008060;
  }

  .unlimited-variant-select:focus {
    outline: none;
    border-color: #008060;
    box-shadow: 0 0 0 3px rgba(0, 128, 96, 0.1);
  }

  .unlimited-variant-preview {
    margin-top: 16px;
    padding: 12px;
    background: #f6f6f7;
    border-radius: 6px;
  }

  .unlimited-variant-price {
    font-size: 16px;
    font-weight: 600;
    color: #008060;
    margin-bottom: 4px;
  }

  .unlimited-variant-stock {
    font-size: 13px;
    color: #6d7175;
  }

  .unlimited-modal-footer {
    padding: 24px;
    border-top: 1px solid #e3e5e7;
    display: flex;
    gap: 12px;
    justify-content: flex-end;
  }

  .unlimited-modal-cancel {
    padding: 12px 24px;
    border: 2px solid #c9cccf;
    background: white;
    color: #202223;
    font-size: 14px;
    font-weight: 600;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .unlimited-modal-cancel:hover {
    border-color: #008060;
    color: #008060;
  }

  .unlimited-modal-confirm {
    padding: 12px 24px;
    border: none;
    background: #008060;
    color: white;
    font-size: 14px;
    font-weight: 600;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .unlimited-modal-confirm:hover:not(:disabled) {
    background: #006e52;
  }

  .unlimited-modal-confirm:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* Bundle Preview Styles */
  .unlimited-bundle-preview {
    margin-top: 32px;
    padding: 24px;
    background: #f6f6f7;
    border: 2px solid #008060;
    border-radius: 12px;
  }

  .unlimited-bundle-preview-title {
    font-size: 20px;
    font-weight: 700;
    color: #202223;
    margin: 0 0 20px 0;
  }

  .unlimited-bundle-items-list {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .unlimited-bundle-item {
    background: white;
    border: 1px solid #e3e5e7;
    border-radius: 8px;
    padding: 16px;
  }

  .unlimited-bundle-item-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
  }

  .unlimited-bundle-item-name {
    font-size: 16px;
    font-weight: 600;
    color: #202223;
    margin: 0;
  }

  .unlimited-bundle-edit-btn {
    padding: 6px 16px;
    border: 1px solid #008060;
    background: white;
    color: #008060;
    font-size: 13px;
    font-weight: 600;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .unlimited-bundle-edit-btn:hover {
    background: #008060;
    color: white;
  }

  .unlimited-bundle-item-options {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 12px;
  }

  .unlimited-bundle-option {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
    padding: 8px;
    background: #f6f6f7;
    border-radius: 6px;
    position: relative;
  }

  .unlimited-option-name {
    font-weight: 600;
    color: #6d7175;
  }

  .unlimited-option-value {
    color: #202223;
  }

  .unlimited-match-indicator {
    margin-left: auto;
    font-weight: 700;
    font-size: 16px;
  }

  .unlimited-match-exact {
    background: #e8f5f1;
    border-left: 3px solid #008060;
  }

  .unlimited-match-exact .unlimited-match-indicator {
    color: #008060;
  }

  .unlimited-match-nearest {
    background: #fff4e5;
    border-left: 3px solid #ff9800;
  }

  .unlimited-match-nearest .unlimited-match-indicator {
    color: #ff9800;
  }

  .unlimited-match-default {
    background: #f6f6f7;
  }

  .unlimited-bundle-item-price {
    font-size: 18px;
    font-weight: 700;
    color: #008060;
    text-align: right;
  }

  .unlimited-no-variant {
    color: #6d7175;
    font-size: 13px;
    font-style: italic;
    margin: 0;
  }

  @media (max-width: 768px) {
    .unlimited-bundle-item-header {
      flex-direction: column;
      align-items: flex-start;
      gap: 12px;
    }

    .unlimited-bundle-edit-btn {
      width: 100%;
    }
  }
</style>

{% schema %}
{
  "name": "Recommendations Bundle",
  "target": "section",
  "settings": [
    {
      "type": "text",
      "id": "heading",
      "label": "Heading",
      "default": "Complete Your Bundle"
    },
    {
      "type": "range",
      "id": "products_to_show",
      "min": 2,
      "max": 6,
      "step": 1,
      "label": "Number of products to show",
      "default": 3
    },
    {
      "type": "checkbox",
      "id": "show_reason",
      "label": "Show recommendation reason",
      "default": true
    }
  ]
}
{% endschema %}
